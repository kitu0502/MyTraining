Version Control System
Version Control System (VCS) is a software that helps software developers to work together and maintain a complete history of their work.

Listed below are the functions of a VCS -

--Allows developers to work simultaneously.
--Does not allow overwriting each other’s changes.
--Maintains a history of every version.

--Following are the types of VCS -
1.Centralized version control system (CVCS).
2.Distributed/Decentralized version control system (DVCS).

In this chapter, we will concentrate only on distributed version control system and especially on Git. Git falls under distributed version control system.

Distributed Version Control System
Centralized version control system (CVCS) uses a central server to store all files and enables team collaboration. But the major drawback of CVCS is its single point of failure, i.e., failure of the central server. Unfortunately, if the central server goes down for an hour, then during that hour, no one can collaborate at all. And even in a worst case, if the disk of the central server gets corrupted and proper backup has not been taken, then you will lose the entire history of the project. Here, distributed version control system (DVCS) comes into picture.

DVCS clients not only check out the latest snapshot of the directory but they also fully mirror the repository. If the server goes down, then the repository from any client can be copied back to the server to restore it. Every checkout is a full backup of the repository. Git does not rely on the central server and that is why you can perform many operations when you are offline. You can commit changes, create branches, view logs, and perform other operations when you are offline. You require network connection only to publish your changes and take the latest changes.

Advantages of Git
Free and open source
Git is released under GPL’s open source license. It is available freely over the internet. You can use Git to manage property projects without paying a single penny. As it is an open source, you can download its source code and also perform changes according to your requirements.

Fast and small
As most of the operations are performed locally, it gives a huge benefit in terms of speed. Git does not rely on the central server; that is why, there is no need to interact with the remote server for every operation. The core part of Git is written in C, which avoids runtime overheads associated with other high-level languages. Though Git mirrors entire repository, the size of the data on the client side is small. This illustrates the efficiency of Git at compressing and storing data on the client side.

Implicit backup
The chances of losing data are very rare when there are multiple copies of it. Data present on any client side mirrors the repository, hence it can be used in the event of a crash or disk corruption.

Security
Git uses a common cryptographic hash function called secure hash function (SHA1), to name and identify objects within its database. Every file and commit is check-summed and retrieved by its checksum at the time of checkout. It implies that, it is impossible to change file, date, and commit message and any other data from the Git database without knowing Git.

No need of powerful hardware
In case of CVCS, the central server needs to be powerful enough to serve requests of the entire team. For smaller teams, it is not an issue, but as the team size grows, the hardware limitations of the server can be a performance bottleneck. In case of DVCS, developers don’t interact with the server unless they need to push or pull changes. All the heavy lifting happens on the client side, so the server hardware can be very simple indeed.

Easier branching
CVCS uses cheap copy mechanism, If we create a new branch, it will copy all the codes to the new branch, so it is time-consuming and not efficient. Also, deletion and merging of branches in CVCS is complicated and time-consuming. But branch management with Git is very simple. It takes only a few seconds to create, delete, and merge branches.

DVCS Terminologies

Local Repository
Every VCS tool provides a private workplace as a working copy. Developers make changes in their private workplace and after commit, these changes become a part of the repository. Git takes it one step further by providing them a private copy of the whole repository. Users can perform many operations with this repository such as add file, remove file, rename file, move file, commit changes, and many more.

Working Directory and Staging Area or Index
The working directory is the place where files are checked out. In other CVCS, developers generally make modifications and commit their changes directly to the repository. But Git uses a different strategy. Git doesn’t track each and every modified file. Whenever you do commit an operation, Git looks for the files present in the staging area. Only those files present in the staging area are considered for commit and not all the modified files.

Let us see the basic workflow of Git.

Step 1 - You modify a file from the working directory.

Step 2 - You add these files to the staging area.

Step 3 - You perform commit operation that moves the files from the staging area. After push operation, it stores the changes permanently to the Git repository.


----------------------------------------------------------------------------------
Git commands are used for sharing and combining the code easily with other developers.

Git Commands
Following are the some basic Git commands can be used to work with Git -

The version of the Git can be checked by using the below command -
$ git --version

Add Git username and email address to identify the author while committing the information. Set the username by using the command as -
$ git config --global user.name "USERNAME"
After entering user name, verify the entered user name with the below command -
$ git config --global user.name

Next, set the email address with the below command -
$ git config --global user.email "email_address@example.com"

You can verify the entered email address as -
$ git config --global user.email

Use the below command to check the entered information -
$ git config --global --list

You can pull the latest changes made to the master branch by using the below command -
$ git checkout master

You can fetch the latest changes to the working directory with the below command -
$ git pull origin NAME-OF-BRANCH -u

Here, NAME-OF-BRANCH could be 'master' or any other existing branch.

Create a new branch with the below command -

$ git checkout -b branch-name
You can switch from one branch to other branch by using the command as -

$ git checkout branch-name
Check the changes made to your files with the below command -

$ git status
You will see the changes in red color and add the files to staging as -

$ git add file-name
Or you can add all the files to staging as -

$ git add *
Now send your changes to master branch with the below command -

$ git push origin branch-name
Delete the all changes, except unstaged things by using the below command -

$ git checkout .
You can delete the all changes along with untracked files by using the command as -

$ git clean -f
To merge the different branch with the master branch, use the below command -

$git checkout branch-name
$ git merge master 

You can also merge the master branch with the created branch, by using the below command -
$git checkout master
$ git merge branch-name
-------------------------------------------------------------------
Step 3 : Create a Jenkins job to run this program to perform a simple test
  --New item-->HelloWorld-->Freestyle.
  --build-->Execute windows batch command
          cd D:\JavaWorkspace\HelloApp
	   javac Hello.java
	   java Hello
  --save --apply --build 

Step 4 : Add the project to Git and GitHub
 Make sure that git plugin is installed 

git init
git pull https://github.com/.........
git status
git add .
git commit -m "Hello World added successfully"
git remote add origin https://github.com/chhaya.nikam/jenkis-programs.git
git push -u origin master

--------------------------
https://github.com/chhayanikam/jenkisdemo.git

==>git steps Activity
Step 1 : Create a java program(This can be any programming language code) or any file 
in some new folder

--Hello.java
  public class Hello{
	public static void main(String a[])
	{
		for(int i=1;i<=10;i++)
		{
		  System.out.println("Hello world");
		}
	}
}  

save in D:\JavaWorkspace\HelloApp

Step 2 : Compile from command line
   javac “name of .java class”
      java “name of class without extension .java”

step 3: copy the project location folder eg. D:\JavaWorkspace\HelloApp
open the git cmd

step 4:initializa the git repo
D:\JavaWorkspace\HelloApp>git init 
check the current status , files not ready for git push red color

D:\JavaWorkspace\HelloApp>git status
Now add all the files in the current dir
syntax: git add <filename>
D:\JavaWorkspace\HelloApp>git add .

Again check the status, shows green color
D:\JavaWorkspace\HelloApp>git status 

Now perform the git commit
D:\JavaWorkspace\HelloApp>git commit -m "project files commited"

Now lets push the files to git repo
Login to your github account
create a new repository eg. mytraining
copy the location of the repository /move inside the created repository.
git@github.com:chhayanikam/jenkinsdemo.git
D:\JavaWorkspace\HelloApp>git remote add origin git@github.com:chhayanikam/jenkinsdemo.git

D:\JavaWorkspace\HelloApp>git push -u origin master

----------------------------------------------------------------------
git Lifecycle/General workflow is as follows -

--You clone the Git repository as a working copy.

--You modify the working copy by adding/editing files.

--If necessary, you also update the working copy by taking other developer's changes.

--You review the changes before commit.

--You commit changes. If everything is fine, then you push the changes to the repository.

--After committing, if you realize something is wrong, then you correct the last commit and push the changes to the repository.













